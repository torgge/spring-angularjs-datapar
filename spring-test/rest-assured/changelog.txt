Change log next version
-----------------------
* Significantly reduce sized of scala-support distribution package
* Removed the use of StandardCharset from EncoderConfig which prevented EncoderConfig to be used on Java 6 and older.
* Added support for sending a request body in a GET request (issue 544). Thanks to Manuel Möhlmann for pull request.
* Response content-type validation now works correctly even if the response body is empty (issue 566). Thanks to Manuel Möhlmann for pull request.
* Fixing dead links in javadocs (issue 605). Thanks to Ben Severson for pull request.
* Changes to com.jayway.restassured.filter.FilterContext:
   1. getRequestPath now only returns the the actual path of the request URI (previously this returned the request URI) (non-backward compatible change)
   2. getRequestURI returns the entire request URI (new method)
   3. getCompleteRequestPath has been deprecated, use getRequestURI
   4. getOriginalRequestPath has been added which returns the path of the request BEFORE path parameters have been applied to it
* Deprecated "resultHandlers" method in MockMvcRequestSpecification and added "apply" method to com.jayway.restassured.module.mockmvc.response.ValidatableMockMvcResponse that should be used instead.
  For example previously you did "given().resultHandlers(print()).when().get("/x")" but now you do "get("/x").then().apply(print())" (issue 607)
* Automatically escapes "class" keyword in JsonPath and XmlPath (issue 598)
* Taking DecoderConfig into account when parsing non-string content (issue 599)
* It's now possible to supply MockMvcConfigurers when calling standaloneSetup in the Spring Mock MVC module. For example:
      given().standaloneSetup(new Controller1(), springSecurity()). ..
* Automatically adds supports for spring rest docs path parameter documentation if spring-restdocs-mockmvc is in classpath. This can be disabled using the MockMvcConfig (issue 606).
* It's now possible to change port, base path etc from a filter (issue 600)
* Added support for specifying preemptive basic authentication for proxies. For example:
    given().proxy(auth("username", "password")).when() ..
  where "auth" is statically imported from com.jayway.restassured.specification.ProxySpecification (issue 597).

Change log 2.6.0 (2015-10-09)
-----------------------------
* Changed com.jayway.restassured.config.HttpClientConfig$HttpClientFactory from an abstract class to an interface in order to create it as a lambda express in Java 8. Before you had to do like this:
    given().config(RestAssured.config().httpClientConfig(httpClientConfig().httpClientFactory(new HttpClientConfig.HttpClientFactory() {
        @Override
        public HttpClient createHttpClient() {
            return new SystemDefaultHttpClient();
        }
    }));
  but now you can just use a lambda expression or method reference:
    given().config(RestAssured.config().httpClientConfig(httpClientConfig().httpClientFactory(SystemDefaultHttpClient::new));
* Fixed so that the "multiPart(String name, File file, String mimeType)" method doesn't use default control name (issue 588)
* Added support for setting multipart filename when passing in an object to multiPart method (issue 587)
* Multipart file-uploading now takes encoder config into account when serializing content. For example if you're trying to serialize an object
  using mime-type "application/vnd.ms-excel" in a multipart then you can register that it should be serialize as JSON:
    Greeting greeting = new Greeting();
    greeting.setFirstName("John");
    greeting.setLastName("Doe");

    given().
           config(config().encoderConfig(encoderConfig().encodeContentTypeAs("application/vnd.ms-excel", ContentType.JSON))).
           multiPart(new MultiPartSpecBuilder(greeting)
                   .fileName("RoleBasedAccessFeaturePlan.csv")
                   .controlName("text")
                   .mimeType("application/vnd.ms-excel").build()).
    when().
           post("/multipart/text").
    then().
           statusCode(200);
  This will now serialize the "greeting" as JSON even though the mime-type is set to "application/vnd.ms-excel" (which is unknown to REST Assured) (issue 586)
* You can now pass in which ObjectMapperType or ObjectMapper to use when serializing an object using multipart. For example:
    Greeting greeting = new Greeting();
    greeting.setFirstName("John");
    greeting.setLastName("Doe");

    given().
           multiPart(new MultiPartSpecBuilder(greeting, ObjectMapperType.GSON)
                   .fileName("RoleBasedAccessFeaturePlan.csv")
                   .controlName("text")
                   .mimeType("application/vnd.ms-excel").build()).
    when().
           post("/multipart/text").
    then().
           statusCode(200);
  This will force the use if the GSON ObjectMapper (if available in the classpath) even though mime type is not recognized by default by REST Assured.
* Charset for multipart requests is now taken into account
* Content-Type for multipart requests is now taken into account. For example you can now do:
    given().contentType("multipart/mixed").multiPart(..)
  which was not possible in the previous version. (Only "multipart/form-data" worked) (issue 586)
* It's now possible to specify default mime subtype for multipart content-type. Use the MultiPartConfig#defaultSubtype(..) method.
  Default is "form-data" which results in a content-type of "multipart/form-data". This also works for the MockMvc module.
* Upgraded JUnit to 4.12
* Non-backward compatible change: Fixed so that GPath expressions using XML namespaces are evaluated from the root.
  The implementation was previously a misunderstanding of how the Groovy's XmlSlurper worked when using namespace and has now been corrected. For example let's say
  you have a service at "/namespace-example" that returns the following XML:

    <foo xmlns:ns="http://localhost/">
      <bar>sudo </bar>
      <ns:bar>make me a sandwich!</ns:bar>
    </foo>

  You NOW test it like this:

    given().
            config(newConfig().xmlConfig(xmlConfig().declareNamespace("ns", "http://localhost/"))).
    when().
            get("/namespace-example").
    then().
            body("foo.bar.text()", equalTo("sudo make me a sandwich!")).
            body(":foo.:bar.text()", equalTo("sudo ")).
            body("foo.ns:bar.text()", equalTo("make me a sandwich!"));

  In the previous versions you did like this:

    given().
            config(newConfig().xmlConfig(xmlConfig().declareNamespace("ns", "http://localhost/"))).
    when().
            get("/namespace-example").
    then().
            body("bar.text()", equalTo("sudo make me a sandwich!")).
            body(":bar.text()", equalTo("sudo ")).
            body("ns:bar.text()", equalTo("make me a sandwich!"));

  Which was not correct (notice the missing foo property)! Big thanks to Erich Eichinger for spotting this and providing a pull request (issue 592).
* Simplified setting of accept header in the MockMvc module (issue 591)
* It's now possible to use a mapping function when validating headers. For example let's say you want to validate that the Content-Length header is less than 1000.
  You can then use a mapping function to first convert the header value to an int and then use an "integer" Hamcrest matcher:
    when().get("/something").then().header("Content-Length", Integer::parseInt, lessThan(1000));
  This is also implemented for the MockMvc module (issue 594).
* Added new config called ParamConfig that allows you to configure how parameter types should be updated. By default all parameters are merged so if you do:
    given().queryParam("param1", "value1").queryParam("param1", "value2").when().get("/x"). ...
  REST Assured will send a query string of "param1=value1&param1=value2". This is not always what you want though so from now on you can configure REST Assured to replace
  values instead:
    given().
            config(config().paramConfig(paramConfig().queryParamsUpdateStrategy(REPLACE))).
            queryParam("param1", "value1").
            queryParam("param1", "value2").
    when().
            get("/x"). ..
  REST Assured will now replace "param1" with "value2" (since it's written last) instead of merging them together. You can configure the update strategy for each
  parameter type of for all parameter types:
    given().config(config().paramConfig(paramConfig().replaceAllParameters())). ..
  This is also implemented for the MockMvc module (but the config there is called MockMvcParamConfig) (issue 589)
* Non-backward compatible change: When multiple cookies or headers with the same name are returned in the response the LAST value is what's returned when
  only getting one value from the entity (Headers or Cookies) or when validating values. For example let's say that the server returns headers:
    HeaderName: Value 1
    HeaderName: Value 2
  then if you do:
    get("/x").extract().header("HeaderName")
  Value 2 will be returned (previous Value 1 would be returned).
  Likewise if you do validation:
    get("/x").then().header("HeaderName", equalTo("Value 2");
  This change also affects session ids. This is done to be compatible with the way browsers work (issue 543).
* Added ability to specify which encoder charset to use for a specific content-type if no charset is defined explicitly for this content-type.
  Previously you could only specify a default charset for ALL content-types. You do this by using the "defaultCharsetForContentType" method in the
  com.jayway.restassured.config.EncoderConfig. For example:
    RestAssured.config = config(config().encoderConfig(encoderConfig().defaultCharsetForContentType("UTF-16", "application/xml")));
  This will assume UTF-16 encoding for "application/xml" content-types that does explicitly specify a charset.
  By default "application/json" is now specified to use "UTF-8" as default content-type as this is specified by RFC4627.
  This is may be a backward incompatible change since previously "application/json" content-types
  were encoded using the platform default content-type (or what was specified by defaultContentCharset(..)) (issue 567).
* Added ability to specify which decoder charset to use for a specific content-type if no charset is defined explicitly for this content-type.
  Previously you could only specify a default charset for ALL content-types. You do this by using the "defaultCharsetForContentType" method in the
  com.jayway.restassured.config.DecoderConfig. For example:
    RestAssured.config = config(config().decoderConfig(decoderConfig().defaultCharsetForContentType("UTF-16", "application/xml")));
  This will assume UTF-16 encoding for "application/xml" content-types that does explicitly specify a charset.
  By default "application/json" is now specified to use "UTF-8" as default charset as this is specified by RFC4627.
  This is may be a backward incompatible change since previously "application/json" content-types
  were encoded using the platform default content-type (or what was specified by defaultContentCharset(..)).
* Fixed so that com.jayway.restassured.builder.ResponseBuilder register a ResponseParserRegistrar by default to avoid NPE when logging custom built responses.
* Fixed so that com.jayway.restassured.builder.ResponseBuilder now uses status code as status line if no status line was explicitly defined.
* Added ability to set a header in com.jayway.restassured.builder.ResponseBuilder.
* Setting contentType in com.jayway.restassured.builder.ResponseBuilder also sets the header.
* Added ability to pass a ContentType as argument to "setContentType" method in com.jayway.restassured.builder.ResponseBuilder.
* Added a new module called spring-support that adds an alias to the "then" method in Response or MockMvcResponse called "Then".
  The reason for this is that "then" might be a reserved keyword in Scala in the future and the compiler gives a warning when using "then".
  To enable the use of "Then" simply import the "com.jayway.restassured.module.scala.RestAssuredSupport.AddThenToResponse". For example:
    import com.jayway.restassured.RestAssured.when
    import com.jayway.restassured.module.scala.RestAssuredSupport.AddThenToResponse
    import org.hamcrest.Matchers.equalTo
    import org.junit.Test

    @Test
    def `trying out rest assured in scala with implicit conversion`() {
        when().
                get("/greetJSON").
        Then().
                statusCode(200).
                body("key", equalTo("value"))
    }
  This is also support for the spring-mock-mvc module.

Change log 2.5.0 (2015-08-09)
-----------------------------
* MockMvc module now supports async requests. For example "given().body(..).when().async().post("/x").then(). ..". Big thanks to Marcin Grzejszczak (@mgrzejszczak) for helping out.
* Fixed NPE when using logging with a custom filter that doesn't include any headers.
* REST Assured can now resolve multiple path parameters inside the same URI "path parameter" (for example /somewhere/{x}{y}/z)
* Using non-deprecated DateUtils from Apache HTTP Client in CookieMatcher
* Quotations when extracting charset parameter is no longer required (thanks to Ronny Bräunlich for pull request)
* Content specified with a content-type starting with "text/" or containing "+text" is now automatically encoded as using the text encoder (issue 574)
* It's now possible to specify how content for a specific content-type should be serialized using com.jayway.restassured.config.EncoderConfig#encodeContentTypeAs(..).
  For example let's say that you want to serialized content-type "my-custom-content-type" as text:
  given().
          config(RestAssured.config().encoderConfig(encoderConfig().encodeContentTypeAs("my-custom-content-type", ContentType.TEXT))).
          contentType("my-custom-content-type").
          content("Some text content").
  when().
          post("/somewhere"). ..
* Improved escaping of certain attributes (such as 'properties') when parsing JSON and XML (issue 552)
* REST Assured now show all failing body assertions when using multiple expectations in the same body clause. For example:
    .. then().body("x.y", equalTo("z"), "y.z", is(2)). ..
  If both "x.y" and "y.z" fails REST Assured will print both errors. Before only the error of "x.y" was shown.
* Upgraded Groovy from 2.4.3 to 2.4.4
* Pretty-printing of JSON now displays unicode characters correctly (issue 556)
* Fixed so that the specified charset is actually used when calling com.jayway.restassured.path.json.config.JsonPathConfig#charset(String)
* Fixed so that specifying number return type in com.jayway.restassured.path.json.config.JsonPathConfig#numberReturnType(..) doesn't override the other settings
* Added new a new NumberReturnType that can be used with JsonPathConfig in order to always return non-integer numbers as doubles. This also you to for example use the "closeTo" Hamcrest matcher. For example:
  RestAssured.config = RestAssured.config().jsonConfig(jsonConfig().numberReturnType(DOUBLE));
  (issue 571)
* Upgraded optional Scribe dependency for OAuth2 authentication from version 1.3.5 to version 1.3.7.
* Possible to sign the request with an oauth2 access token (in the header) without using Scribe (issue 509)
* Non-backward compatible change: Changed com.jayway.restassured.matcher.ResponseAwareMatcher from an abstract class to a (functional) interface.
  The reason is to allow for creating ResponseAwareMatchers as lambda expressions in Java 8. Before you had to do like this (even in Java 8):
    when().
           get("/game").
    then().
           body("_links.self.href", new ResponseAwareMatcher<Response>() {
               public Matcher<?> matcher(Response response) {
                   return equalTo("http://localhost:8080/" + response.path("id"));
               }
           });
  but with the new change you can now do (if using Java 8):
    when().
           get("/game").
    then().
           body("_links.self.href", response -> equalTo("http://localhost:8080/" + response.path("id")));
  which is much less verbose. This change should be backward compatible unless you use composition of matchers. Before you composed ResponseAwareMatchers like this:
    when().
           get("/game").
    then().
           body("_links.self.href", responseAwareMatcher1.and(responseAwareMatcher2));
  This now longer works (since we cannot implement default methods in the ResponseAwareMatcher interface in order to be compatible with older Java versions)
  so now you use the new com.jayway.restassured.matcher.ResponseAwareMatcherComposer class to compose ResponseAwareMatchers instead:
    when().
           get("/game").
    then().
           body("_links.self.href", and(responseAwareMatcher1, responseAwareMatcher2));
  where "and" is statically imported from ResponseAwareMatcherComposer. These can also be nested and combined with regular Hamcrest matchers, for example:
    when().
           get("/game").
    then().
           body("_links.self.href", and(responseAwareMatcher1, containsString("something"), or(responseAwareMatcher2, responseAwareMatcher3, endsWith("x"))));
  (issue 575)
* Updated com.github.fge.json-schema-validator from version 2.2.5 to 2.2.6 in the json-schema-validator module
* Non-backward compatible change: multiPart methods taking java.io.File as argument now uses the filename of the File instead of just "file".
* Fixed a NPE when using ResponseBuilder without setting a status code.
* Multipart file uploading now supports specifying an empty filename.
* It's now possible to set default filename and control name for multiparts. Before they were always equal to "file" but this is now configurable using the new MultiPartConfig. For example:
    given().config(config().multiPartConfig(multiPartConfig().with().defaultFileName("custom1").and().defaultControlName("custom2"))). ..
  This is also implemented for the Spring Mock MVC module.
* Upgraded Spring from version 4.1.6.RELEASE to 4.2.0.RELEASE in the spring-mock-mvc module
* Upgraded Spring Security from version 3.2.5.RELEASE to 4.0.2.RELEASE in the spring-mock-mvc module
* Added support for RequestPostProcessor authentication to the Spring Mock MVC module. For example:
     given().auth().with(httpBasic("username", "password")). ..
  where "httpBasic" is statically imported from org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors. This requires that you have "spring-security-test" in your classpath.
* Added support for RequestPostProcessors to the Spring Mock MVC module, for example:
    given().postProcessors(myRequestPostProcessor1, myRequestPostProcessor2). ..
* It's now possible to supply MockMvcConfigurers when calling webAppContextSetup in the Spring Mock MVC module. For example:
    given().webAppContextSetup(context, springSecurity()). ..
* Non-backward compatible change: The field "RestAssuredMockMvc.mockMvc" has been replaced by a method: "RestAssuredMockMvc.mockMvc(..)". Before you did:
    RestAssuredMockMvc.mockMvc = myMockMvcInstance;
  but now you need to do:
    RestAssuredMockMvc.mockMvc(myMockMvcInstance);
* Added RestAssuredMockMvc#config() method that returns the assign static config or a new config if no static config has been assigned
* Spring Mock MVC module automatically registers org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurer as request post processor if spring-security-test is available in classpath.
  This means that you don't have to create a custom MockMvc instance with a "SecurityMockMvcConfigurer" manually which means easier setup.
* Added MockMvcConfig to RestAssuredMockMvcConfig which allows you to configure whether or not SecurityMockMvcConfigurer should be applied by default (default is true). To disable it use:
    given().config(config().mockMvcConfig(mockMvcConfig().dontAutomaticallyApplySpringSecurityMockMvcConfigurer())). ..
* Added ability to supply an instance of MockMvcBuilder to the standaloneSetup method in MockMvcRequestSpecification.
* Added support for standalone setup (setStandaloneSetup) and web app context setup (setWebAppContextSetup) in MockMvcRequestSpecBuilder.

Change log 2.4.1 (2015-04-12)
----------------------------
* DefaultJackson2ObjectMapperFactory now scans and registers additional modules (issue 385)
* FilterableRequestSpecification#getPort now returns the correct port and not just -1.
* Upgraded to Groovy 2.4.3
* Upgraded Spring dependencies from 4.1.2.RELEASE to version 4.1.6.RELEASE in the Spring MockMvc module.
* REST Assured now allows specifying "File" and "InputStream" as request body.
* REST Assured MockMvc now allows specifying "File" as body.

Change log 2.4.0 (2014-11-15)
-----------------------------
* The "matcherConfig" method in com.jayway.restassured.config.MatcherConfig is now static as intended.
* Fixed an issue in com.jayway.restassured.internal.path.xml.mapping.XmlPathJaxbObjectDeserializer that prevented parsing when XmlRootElement wasn't used.
* defaultContentCharset and defaultQueryParameterCharset in com.jayway.restassured.config.EncoderConfig now accepts a java.nio.charset.Charset as parameter (issue 363).
* com.jayway.restassured.config.DecoderConfig now accepts a java.nio.charset.Charset as parameter (issue 363).
* Content-Type expectations are now matched by using ignore case.
* Content-Type is now sent to the server if explicitly defined by a GET request (issue 362).
* Added syntactic sugar method "logRequestTo" to com.jayway.restassured.filter.log.RequestLoggingFilter as a shortcut for doing "new RequestLoggingFilter(printStream)".
* Default Content-Type charset is now visible in the request log.
* Default Content-Type charset is now appended to Content-Type header in Spring MockMvc module by default. Use "given().config(RestAssuredMockMvcConfig.config().encoderConfig(encoderConfig().appendDefaultContentCharsetToContentTypeIfUndefined(false))). .." to revert to previous behavior.
* PUT now uses content-type application/x-www-form-urlencoded by default when using form parameters.
* Content-Type is now correctly displayed in request log when not explicitly defined.
* Content-Type charset is now available in Filters when calling getRequestContentType() on the request specification.
* Deprecated RestAssured.responseContentType(..). Use com.jayway.restassured.builder.ResponseSpecBuilder#expectContentType(com.jayway.restassured.http.ContentType) and assign it to RestAssured.responseSpecification instead.
* Deprecated RestAssured.requestContentType(..). Use com.jayway.restassured.builder.RequestSpecBuilder#contentType(com.jayway.restassured.http.ContentType) and assign it to RestAssured.requestSpecification instead.
* Non-backward compatible change: Setting contentType on a ResponseSpecification no longer sets the accept header automatically. Previously this led to confusion and prevented separation between the ResponseSpecification and the RequestSpecification.
* Added "accept" method to RequestSpecification to easier allow setting the Accept header. Also added setAccept to RequestSpecBuilder.
* Added ability to configure if headers should be merged or overwritten when multiple headers with the same name are specified by using the new com.jayway.restassured.config.HeaderConfig. By default content-type and accept headers are now overwritten instead of merged. For example to configure "header1" to be overwritten instead of merged you can do:
    RequestSpecification spec = new RequestSpecBuilder.addHeader("header1", "value2").build();
    given().
            config(RestAssuredConfig.config().headerConfig(headerConfig().overwriteHeadersWithName("header1"))).
            header("header1", "value1").
            spec(spec).
    when().
            get(..)

    will only send one header, "header1" with value "value2".
* Fixed an issue in com.jayway.restassured.config.ObjectMapperConfig#defaultObjectMapperType(..) that reset state to default values.
* Added asList method to Headers to make easier to transform them to a list.
* Added method "hasSameNameAs" to com.jayway.restassured.response.Header.
* Configurations are now overwritten only if they've been explicitly configured when applying a specification. For example:
    RequestSpecification spec = new RequestSpecBuilder.config(config().headerConfig().overwriteHeadersWithName("header1")).build();

    given().
            config(config().sessionConfig(sessionConfig().sessionIdName("phpsessionid"))).
            spec(spec).
            ..
    when().
            get(..)

    This will now cause the resulting config to include both the header config and session config. Before this change ONLY header config would be applied since all configs from the specs were overwritten. This also applies to the MockMvc extension.
* Upgraded Spring version for RestAssuredMockMvc from version 4.0.6.RELEASE to 4.1.2.RELEASE.
* Upgraded Groovy from version 2.3.6 to 2.3.7.
* Upgraded commons-fileupload for RestAssuredMockMvc from version 1.2.2 to version 1.3.1.
* Upgraded httpclient from version 4.3.5 to version 4.3.6.
* It's now possible to specify the SSLContext protocol when configuring "relaxedHTTPSValidation" in SSLConfig. For example sslConfig.relaxedHTTPSValidation("TLS"). Default is SSL just as in previous versions. (issue 367).
* You can now send form parameters with a GET request in accordance with RFC1866 (page 46, HTML 4.x section 17.13.3). Form parameters will be added a query parameters for a GET request and Content-Type will automatically be set to "application/x-www-form-urlencoded" with the default charset.
* Added ability to log request method and request path. Use "given().log().method()" and "given().log().path()" (issue 368).

Change log 2.3.4 (2014-10-06)
-----------------------------
* XmlXsdMatcher#matchesXsdInClasspath(..) now returns an instance of XmlXsdMatcher so that you can easily set a LSResourceResolver.
* ObjectMapperResolver looks for third party libraries in both thread context- and ObjectMapperResolver classloader.
* It's now possible to configure the way error messages are generated in REST Assured using the com.jayway.restassured.config.MatcherConfig. For example:
    given().config(RestAssured.config().matcherConfig(new MatcherConfig(HAMCREST))). ..
  will generate error messages that are close to original Hamcrest messages. The other option is REST_ASSURED which uses the default error messages generated by REST Assured.
* Made it possible to configure whether to automatically append charset to content-type for all content types using the EncoderConfig (issue 355).
* Deprecated "appendDefaultContentCharsetToStreamingContentTypeIfUndefined" in EncoderConfig. Just use "appendDefaultContentCharsetToContentTypeIfUndefined" instead.
* Added ability to remove parameters from a request specification using the RequestSpecBuilder (thanks to Merkushev Kirill for the help).
* Fully-qualified baseUris will no longer have to use explicit port 80 (issue 353)

Change log 2.3.3 (2014-08-29)
----------------------------
* Added CSRF (cross-site request forgery) support to form authentication config. For example:
    given().
            auth().form("John", "Doe", formAuthConfig().withAutoDetectionOfCsrf()).
    when().
            get("/formAuthCsrf");
  This example tries to find the field specifying the CSRF token automatically but it's also possible to define it:
    given(). auth().form("John", "Doe", formAuthConfig().withCsrfFieldName("_csrf")). ..
  Note that REST Assured must always make an additional request to the server if enabling CSRF support.
* com.jayway.restassured.internal.print.ResponsePrinter now returns the entire response (including headers, parameters etc) and not just the body.
* Fixed so that all parameters are taken into account in RequestSpecBuilder when adding a multi-part with the controlName, contentBody, mimeType signature (issue 343).
* Upgraded Spring version for RestAssuredMockMvc from version 4.0.5.RELEASE to 4.0.6.RELEASE.
* Upgraded Spring Security optional dependency from version 3.2.0 to 3.2.5.RELEASE.
* Upgraded faster Jackson optional dependency from version 2.4.0 to 2.4.2.
* Upgraded commons-lang3 from version 3.1 to 3.3.2.
* Upgraded Groovy from version 2.3.2 to 2.3.6.
* Upgraded Http Client from version 4.2.6 to 4.3.5.
* Made it possible to configure whether to automatically append charset to content-type for streaming content using the EncoderConfig (issue 345).
* Support for request attributes in spring-mock-mvc (thanks to Jacek Kunicki for the pull request)
* JsonSchemaValidator no longer parse URI's and URL's as JsonNode's by default since prevented resolving relative $ref in a parent schema. This is configurable using the JsonSchemaValidatorSettings (issue 346).
* Fixed so that request and response is logged when "enableLoggingOfRequestAndResponseIfValidationFails" is defined when a response specifications fails to validate (issue 350).
* Fixed so that multi-part file data uploading works for files without specifying an explicit filename when using HTTP Client version 4.3 and above (issue 351).

Change log 2.3.2 (2014-06-09)
-----------------------------
* Fixed an issue with logging of request and response using RestAssured.enableLoggingOfRequestAndResponseIfValidationFails() for certain validations.
* Fixed issue with content-type validation when no content-type was sent from the server.
* Updated Groovy to version 2.3.2
* Widen the standaloneSetup builder method in Spring MVC module to accept a AbstractMockMvcBuilder (issue 321).
* Added possibility to include parameters in JsonPath and XmlPath to prevent injection weaknesses (issue 328).
* Added "matchesXsdFromClasspath" to com.jayway.restassured.matcher.RestAssuredMatchers and com.jayway.restassured.module.mockmvc.matcher.RestAssuredMockMvcMatchers (issue 330).
* Added "matchesDtdFromClasspath" to com.jayway.restassured.matcher.RestAssuredMatchers and com.jayway.restassured.module.mockmvc.matcher.RestAssuredMockMvcMatchers (issue 331).
* Upgraded Spring MVC module to depend on Spring 4.0.5. (issue 335)
* Added possibility to use "no wrap" for response streams of type gzdeflate (RFC 1951) used by e.g. PHP. Usage example: given().config(config().decoderConfig(decoderConfig().useNoWrapForInflateDecoding(true))).when().get("/x"). (issue 327).
* basePath can now be set in the RequestSpecification as well as RequestSpecBuilder (issue 325).
* Static usage of "enableLoggingOfRequestAndResponseIfValidationFails" can now be assigned after static request and response configurations (issue 323).
* Multipart parameters are now logged when logging the request specification (issue 144).
* Added ability to get multipart parameters from com.jayway.restassured.specification.FilterableRequestSpecification using the "getMultiPartParams" method.
* Added "replaceFiltersWith" method to RestAssured which makes it possible to replace statically defined filters (issue 174).
* Added support for specifying arguments to root or append paths at a later stage, for example:
    when().
         get("/jsonStore").
    then().
         root("store.%s", withArgs("book")).
         body("category.size()", equalTo(4)).
         appendRoot("%s.%s", withArgs("author")).
         body(withArgs("size()"), equalTo(4)); // The last argument defined in "appendRoot" is applied here
 (issue 267).
* Added ability to log the request and response generated by the form authentication scheme, for example:
    given().
            auth().form("John", "Doe", springSecurity().withLoggingEnabled()).
    when().
            get("/formAuth").
    then().
            statusCode(200).
            body(equalTo("OK"));
  (issue 274).
* Fixed so that CharsetExtractor no longer fails to extract the charset when more than one key=value pair present in the content-type header (issue 337).
* Updated json-schema-validator module to use version 2.2.5 of FGE's json schema validator project.
* Updated commons-lang3 dependency to version 3.3.2.
* Added static compilation to inner class PathType to avoid IncompatibleClassChangeError because of a bug in Groovy (GROOVY-6080) (issue 336).
* Added better proxy support. For example:
    given().proxy("localhost", 8888). ..
  or for all requests:
    RestAssured.proxy("localhost", 8888);
    RestAssured.proxy = host("localhost").withPort(8888); // "host" is statically imported from com.jayway.restassured.specification.ProxySpecification.
  or using a RequestSpecification:
    RequestSpecification specification = new RequestSpecBuilder().setProxy("localhost").build();
    given().spec(specification). ..
  The proxy details are also visible in the request log and are available from the com.jayway.restassured.specification.FilterableRequestSpecification.
  (issue 214).

Change log 2.3.1 (2014-03-31)
-----------------------------
* Fixed a bug where fully-qualified URLs showed up as localhost in the request path in logging (issue 304).
* Fixed a NPE when parsing no-value cookies in HTTP response (issue 306).
* Query params and values now splits the '=' with max count 2 (issue 305).
* Added support for HttpOnly cookies (thanks to Luke Bunselmeyer for pull request).
* Added support for specifying properties in XmlConfig and XmlPathConfig.
* Updated json-schema-validator module to use version 2.1.8 of FGE's json schema validator project.
* Fixed bug where query parameters with an empty value are no longer treated as query parameters without a value (issue 314).
* Fixed issue where response could not be created using the ResponseBuilder if using the given-when-then syntax.
* It's now possible to supply a resource resolver when matching XSD. For example:
    get("/x").then().body(matchesXsd(load("main.xsd")).using(new ClasspathResourceResolver()));
  (issue 317).
* Upgraded Spring MVC module to depend on Spring 4.0.3.RELEASE.
* Fixed a bug with JsonPath that prevented parsing of JSON attributes starting with a number (issue 318).
* Added appendRootPath method to ResponseSpecBuilder
* Added noRootPath method to ResponseSpecBuilder
* Added detachRoot method to ResponseSpecification that allows you to detach parts of the root paths (issue 319).
* Added detachRootPath method to ResponseSpecBuilder.
* "appendRoot" method in ResponseSpecification can now be used even though no root path has previously been set.
* Added a RestAssuredMockMvc.standaloneSetup(DefaultMockMvcBuilder) method in order to allow more flexible customization of the spring context (thanks to Martin Ahrer for the pull request) (issue 321).
* Added static "with" method to RestAssuredMockMvc that can be used instead of "given" if needed (issue 320).
* Added support for logging the request specification or response specification if the test validation fails. For example:
    given().log().ifValidationFails(). ..
  will log the request only if REST Assured's validations fail. It's also applicable for the response. This works in both vanilla REST Assured and REST Assured Mock Mvc (issue 212).
* Added support for logging both the request specification and response specification if the test validation fails. For example:
    RestAssured.config = RestAssured.config().logConfig(logConfig().enableLoggingOfRequestAndResponseIfValidationFails());
  There's also a shortcut for this:
    RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();
  This has also been implemented in RestAssuredMockMvc (issue 212).
* Fixed so that pretty logging of the response body doesn't change the body returned to the matchers.
* Fixed so that it's possible to log data with charset binary.
* Getting a String from the response now stores the content as a byte-array internally to avoid messing up binary content.
* Added tagsoup as transitive dependency to XmlPath so that it's easier to get started with HTML parsing (issue 311).

Change log 2.3.0 (2014-01-23)
-----------------------------
* Fixed an IllegalArgumentException with reusable response specifications when defined before other body expectations when using the given-when-then API.
* Non-backward compatible change: The json-path module accidentally depended on faster-jackson, jackson, gson and simple-json and brought then in as transitive dependencies. This has now been resolved which means that these dependencies are optional as intended (issue 297).
* Fixed serious issues with SSL config and certificate authentication. A TrustStore as accidentally used as a KeyStore which caused errors like: "sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target".
* Added support for adding a SSLSocketFactory to SSLConfig (issue 170).
* RestAssuredMockMvc is now using "/" as default basePath so that you can use non-arg HTTP methods (such as get()) without first defining a basePath (issue 296).
* Add static "when" method to RestAssuredMockMvc (issue 295).
* Added support for specifying a trust store, either using the DSL using given().trustStore(..), or statically using RestAssured.trustStore(..) (issue 299).
* Added support for relaxed https validation. This means that you'll trust all hosts regardless if the SSL certificate is invalid. By using this you don't need to specify a keystore or trust store. For example:
    given().relaxedHTTPSValidation().when().get("https://some-url-with-invalid-cert.com"). ..
  You can also define it statically for all requests:
    RestAssured.useRelaxedHTTPValidation();
  (issue 298)
* Added support for authentication in RestAssuredMockMvc. You can now do e.g. given().auth().principal(..). Some auth methods require Spring Security to be on the classpath (optional). It's also possible to defined authentication statically:
    RestAssuredMockMvc.authentication = principal("username", "password");
  where the "principal" method is statically imported from RestAssuredMockMvc. It's also possible to define an authentication scheme in a request builder:
    MockMvcRequestSpecification spec = new MockMvcRequestSpecBuilder.setAuth(principal("username", "password")).build();
* Non-backward compatible change: Statically defined configuration (such as RestAssured.config = ..) is now automatically applied to RequestSpecBuilders in both RestAssured and RestAssuredMockMvc. To revert to previous behavior you can do
    new RequestSpecBuilder.config(newConfig()). ..
* Updated Groovy dependency to 2.2.1.
* MockMvcResponse now allows you to extract the MvcResult and MockHttpServletResponse (issue 294).
* Added support for using parts of the response when verifying the response. For example consider the following JSON document returned from service x:
    { "userId" : "some-id", "href" : "http://localhost:8080/some-id" }
  You may notice that the "href" attribute ends with the value of the "userId" attribute. If we want to verify this we can implement a com.jayway.restassured.matcher.ResponseAwareMatcher and use it like this:
    get("/x").then().body("href", new ResponseAwareMatcher<Response>() {
                                        public Matcher<?> matcher(Response response) {
                                              return equalTo("http://localhost:8080/" + response.path("userId"));
                                        }
                                  });
  There are some predefined matchers that you can use defined in the com.jayway.restassured.matcher.RestAssuredMatchers (or com.jayway.restassured.module.mockmvc.matcher.RestAssuredMockMvcMatchers if using the spring-mock-mvc module). For example:
    get("/x").then().body("href", endsWithPath("userId"));
  (issue 288).
* Fixed NPE in RestAssuredMockMvc when path is null.

Change log 2.2.0 (2014-01-08)
-----------------------------
* Fixed an issue with content-type identification when passing in content-type header manually using a header.
* Header values supplied to request specification using a java.util.Map are now serialized if needed.
* Path parameters can now be used in the entire path, not just between two slashes (issue 275, 292).
* Added ability to set logging from the RequestSpecBuilder, for example new RequestSpecBuilder().log(ALL).build();
* Response specifications are now validated correctly when passed to spec or specification method after then is called. For example:
    ResponseSpecification specification = new ResponseSpecBuilder().expectStatusCode(200).expectBody("greeting", equalTo("Greetings John Doe")).build();
    given().
            param("firstName", "John").
            param("lastName", "Doe").
    when().
            get("/greet").
    then().
            spec(specification);
* REST Assured now supports OAuth2 authentication using the Scribe framework (https://github.com/fernandezpablo85/scribe-java). Big thanks to Waseem Shaik for all the help!
* Non-backward compatible change: REST Assured now use the Scribe framework (https://github.com/fernandezpablo85/scribe-java) instead of Signpost for oauth1 authentication so you need to update your classpath dependencies. Please read the release notes for more info.
* Added Spring Mock Mvc (Spring test) module which let's you unit test Spring MVC controllers using the REST Assured DSL. Depend on artifact id "spring-mock-mvc" using group id "com.jayway.restassured" from Maven to use it. Then use RestAssuredMockMvc to get started.
* Fixed so that RestAssured.given(requestSpecification) now merges the static request specification correctly.

Change log 2.1.0 (2013-12-09)
-----------------------------
* Changed the way REST Assured finds key stores in classpath. It now uses thread context classloader to resolve the files instead of the class KeyStoreSpecImpl classloader.
  This means means that you're able to do e.g. "RestAssured.keystore("keystore.jks", "test1234")" where you before used "RestAssured.keystore("/keystore.jks", "test1234")".
* java.util.UUID is now serialized as a String (issue 285).
* Non-backward compatible change: It's no longer possible to assert that an empty response object has a path that is null, for example let's say that the "/statusCode409WithNoBody" resource returns an empty body:
    expect().contentType(ContentType.JSON).body("error", equalTo(null)).when().get("/statusCode409WithNoBody"); // This will now throw assertion error
* Added support to for mixing text and path assertions. For example:
    get("/lotto").then().body(containsString("\"numbers\":[52")).and().body("lotto.winners.winnerId", hasItems(23, 54));
* Non-backward compatible change: Changed default response content charset from ISO-8859-1 to system default charset. The reason for this that most users would probably expect the system default charset. To change the behavior use the DecoderConfig (issue 283).
* Non-backward compatible change: Changed default request content charset from ISO-8859-1 to system default charset. The reason for this that most users would probably expect the system default charset. To change the behavior use the EncoderConfig (issue 283).
* REST Assured now supports JSON schema validation (http://json-schema.org/). To allow for this you need to add the json schema validator module to classpath. Once you done that you should statically import "com.jayway.restassured.module.jsv.JsonSchemaValidator.*" and then you can do e.g.
    get("/products").then().assertThat().body(matchesJsonSchemaInClasspath("products-schema.json"));
  (issue 284)
* Non-backward compatible change: Removed the following method from the RestAssured API: "certificate(String certURL, String password, String certType, int port, KeystoreProvider trustStoreProvider, boolean checkServerHostname)" and "certificate(String certURL, String password, String certType, int port, KeystoreProvider trustStoreProvider)".
* Deprecated the following method from the RestAssured API: "certificate(String certURL, String password, String certType, int port)", "certificate(String certURL, String password, String certType, int port, KeystoreProvider trustStoreProvider, boolean checkServerHostname)". It's replaced by the "certificate(String certURL, String password, CertificateAuthSettings certificateAuthSettings)" method. For example:
    RestAssured.authentication = certificate(certUrl, password, certAuthSettings().with().port(435));
* Non-backward compatible change: Removed the following method from the AuthenticationSpecification API: "certificate(String certURL, String password, String certType, int port, KeystoreProvider trustStoreProvider, boolean checkServerHostname)" and "certificate(String certURL, String password, String certType, int port, KeystoreProvider trustStoreProvider)".
* Deprecated the following method from the AuthenticationSpecification API: "certificate(String certURL, String password, String certType, int port)". It's replaced by the "certificate(String certURL, String password, CertificateAuthSettings certificateAuthSettings)" method. For example:
    given().auth().certificate(certUrl, password, certAuthSettings().with().port(435)). ..
* Added support for disabling hostname verification by disabling this using the CertificateAuthSettings:
    given().auth().certificate(certUrl, password, certAuthSettings().with().allowAllHostnames(). ..
  (issue 182)
* Non-backward compatible change: Removed static method "RestAssured.keystore()". You can now get the keystore settings from the SSL configuration instead.
* Non-backward compatible change: Removed the com.jayway.restassured.authentication.KeyStoreProvider interface. The KeyStoreProvider was actually NOT used to create a KeyStore but rather a trust store. To specify the trust store after this change use the SSLConfig or certificate authentication.
* Non-backward compatible change: All keystore related methods in the RestAssured API now returns void instead of KeyStoreSpec.
* You can now get the current REST Assured configuration by calling RestAssured.config()
* Non-backward compatible change: Removed method "RestAssured.keyStore()". If you want to get the configured "keystore" configuration you can now call "RestAssured.config().getSSLConfig();".

Change log 2.0.1 (2013-11-29)
-----------------------------
* Fixed an issue which prevented extracting data from a response after body assertions had been used.

Change log 2.0.0 (2013-11-29)
-----------------------------
* Fixed a regression bug where Rest Assured didn't respected trailing slashes in URL's (issue 276).
* Fixed so that the path method in the Response can be invoked multiple times, for example:
    Response response = get("/jsonStore");
    float minPrice = response.path("store.book.price.min()");
    float maxPrice = response.path("store.book.price.max()");
  (issue 280)
* Fixed so that JsonPath and XmlPath and path expressions work after the "prettyPrint" and "print" methods have been called on a Response instance.
* Added support for performing requests with URI's and URL's, for example:
    URI myUri = new URI(..)
    Response response = get(myUri);
  (issue 278)
* Added possibility to call request methods without any parameters. This is useful if you want to call the root resource. For example:
    RestAssured.baseURI = "http://localhost:8080/hello";
    String y = get().path("x.y");
  (issue 279)
* It's now possible to call asString() on a Response object after asByteArray() has been called and vice versa.
* given(requestSpecification) now returns the RequestSpecification instead of RequestSender
* Added support for given-when-then syntax, for example:
      given().
              param("firstName", "John").
              param("lastName", "Doe").
      when().
              get("/greet").
      then().
              statusCode(200).
              body("greeting", equalTo("Greetings John Doe"));
* Added peek and prettyPeek support to com.jayway.restassured.response.Response which allows you to print the response to system out but continue working with the Response instance afterwards.
* Fixed a bug with RequestSpecBuilder that merged two too many cookies and headers when defined statically (issue 281).
* Fixed a bug with ResponseSpecBuilder that didn't merge certain properties correctly.
* Added static method "when" to com.jayway.restassured.RestAssured that allows you to write specifications without use of parameters, headers etc. For example:
      when().
             get("/x").
      then().
             body("x.y.z1", equalTo("Z1")).
             body("x.y.z2", equalTo("Z2"));
* Added support for arguments when calling path("..") on a Response object, for example:
      String z = get("/x").path("x.y.%s", "z");

Change log 1.9.0 (2013-11-25)
-----------------------------
* It's now possible to validate if the ResponseSpecification is fulfilled by calling the validate method and passing in a Response object (thanks to Ian Forsey for the patch).
* Getting cookies as a Map now returns the last value returned instead of the first one if multiple cookies with the same name are sent from the server to comply with the HTTP specification (thanks to DeviKiran Setti for the patch) (issue 257).
* Fixed an issue with merging session ids when merging request specifications.
* Fixed an issue with merging baseUri and port when merging request specifications.
* Added ability to set base uri on the RequestSpecBuilder (issue 252).
* CookieMatcher initialized cookie version with -1 if value was "0" (thanks to Sergey Podgurskiy for the patch)
* Fixed stackoverflow in certificate authentication (issue 262) (thanks to douglasdedo for the patch)
* It's now possible to configure the HTTP Client instance to be used by REST Assured when making requests. Use the HttpClientConfig and specify a http client factory if you want to do this. This makes it possible for some advanced configuration not exposed by the REST Assured API (issue 203).
* Request filters now expose the http client instance which makes it possible to alter some advanced settings not exposed by REST Assured.
* The xmlPath method in the REST Assured response (com.jayway.restassured.response.Response) now accepts a CompatibilityMode. This means that it's easy to get values from HTML responses:
      String pageTitle = get("/index.html").xmlPath(CompatibilityMode.HTML).getString("html.head.title");
  (issue 258)
* Fixed a NPE when trying to parse an empty JSON response (issue 260).
* Added ability to set base uri from RequestSpecBuilder (issue 252).
* Fixed a bug where RequestSpecification was not checked against the correct type when merging request specifications.
* Fixed a bug with pretty printing that sometimes didn't take user supplied value into account.
* It's now possible to configure content decoders. Before GZIP and DEFLATE were always activated and there was no way to disable them. It's now possible to configure which to use, for example to remove GZIP but retain DEFLATE you can do the following:
	  given().config(newConfig().decoderConfig(decoderConfig().contentDecoders(DEFLATE))). ..
  (issue 77)
* The http client instance can now be reused between REST Assured requests. By default REST Assured creates a new instance for each "given" statement. To configure reuse do the following:
      RestAssured.config = newConfig().httpClient(httpClientConfig().reuseHttpClientInstance());
* Added support for appending a root path to an existing root path using "appendRoot" on the RequestSpecification, see javadoc for more info. (issue 248).
* Added support for resetting an already defined root by using "noRoot" on the RequestSpecification, see javadoc for more info. (issue 248).
* Added the "given(requestSpecification)" method to the RestAssured API (issue 56).
* Added support for body expectations with empty path and only arguments, for example expect().root("x.y.%s").body(withArgs("z"), equalTo("w")). .. (issue 265)
* Added support for body expectations without any arguments using withNoArgs() or withNoArguments, for example:
      expect().
               root("store.%s", withArgs("book")).
               body("category.size()", equalTo(4)).
               appendRoot("%s.%s", withArgs("author", "size()")).
               body(withNoArgs(), equalTo(4)).
      when().
               get("/jsonStore");
  (issue 266)
* Added method "htmlPath" to REST Assured Response which allows you to easily get values from an HTML page:
      String pageTitle = get("/index.html").htmlPath().getString("html.head.title");
  (issue 268)
* Fixed an issue where a static preemptive basic authentication couldn't be overridden by instance authentication (issue 233).
* Fixed an issue where multi-valued query parameters defined in the URL now works. For example get("/x?y=1&y=2") (issue 169, 219).
* Improved request logging so that query parameters are included in the complete path.
* Allow URLs that contains double slashes, for example get("/x/y/http://localhost:8080")
* URL encoding (and disabling of URL encoding) has been completely re-written and will now work better (issue 181).
* Fixed issues that made an incorrect port being used under certain conditions (issue 217).
* Fixed so that Hamcrest's hasXPath() and not() can be combined (issue 215).
* Fixed a bug in XmlPathConfig when setting charset.
* It's now possible to use the Hamcrest XPath matcher with namespaces if XmlConfig in REST Assured is configured to be namespace aware, e.g.
      given().
              config(newConfig().xmlConfig(xmlConfig().with().namespaceAware(true))).
      expect().
              body(hasXPath("/db:package-database", namespaceContext)).
      when().
              get("/package-db-xml");
  (issue 39)
* Added possibility to add features to the javax.xml.parsers.DocumentBuilderFactory instance used by REST Assured when parsing XML for XPath validation. Use the XmlConfig to add achieve this.
* Namespaces are now included when pretty printing or logging XML.
* Added namespace support for body expectations if the namespace is declared correctly, for example given the following XML:
      <foo xmlns:ns="http://localhost/">
         <bar>sudo </bar>
         <ns:bar>make me a sandwich!</ns:bar>
      </foo>
  you can verify it like this:
      given().
              config(newConfig().xmlConfig(xmlConfig().declareNamespace("ns", "http://localhost/"))).
      expect().
              body("bar.text()", equalTo("sudo make me a sandwich!")).
              body(":bar.text()", equalTo("sudo ")).
              body("ns:bar.text()", equalTo("make me a sandwich!")).
      when().
              get("/namespace-example");
  (issue 39)
* XmlPath returned from REST Assured Response now takes features, namespaces, charset etc into account.
* XmlPathConfig supports declaring namespaces which means that XmlPath is now namespace aware if needed.
* Added ability to supply an XmlPathConfig instance when using the xmlPath() method from a REST Assured Response object. For example :
      XmlPath xmlPath = get("/namespace-example").xmlPath(xmlPathConfig().with().declaredNamespace("ns", "http://localhost/"));
* Non-backward compatible change: RestAssuredConfig no longer accepts a JsonPathConfig, it now uses a JsonConfig object instead.
* Added ability to supply a JsonPathConfig instance when using the jsonPath() method from a REST Assured Response object. For example :
      JsonPath jsonPath = get("/namespace-example").jsonPath(jsonPathConfig().with().numberReturnType(BIG_DECIMAL));
* Added peek and prettyPeek support to XmlPath which allows you to print the content to system out but continue working with XmlPath afterwards (issue 271).
* Added peek and prettyPeek support to JsonPath which allows you to print the content to system out but continue working with JsonPath afterwards (issue 272).
* FormAuthFilter is now added first to the filter chain.
* Added hasValue(..) method to com.jayway.restassured.filter.FilterContext.
* Added support for sessions by applying the com.jayway.restassured.filter.session.SessionFilter, for example:
      SessionFilter sessionFilter = new SessionFilter();

      given().
              auth().form("John", "Doe").
              filter(sessionFilter).
      expect().
              statusCode(200).
      when().
              get("/formAuth");

      given().
              filter(sessionFilter). // Reuse the same session filter instance to automatically apply the session id from the previous response
      expect().
              statusCode(200).
      when().
              get("/formAuth");
  (issue 229, 273)
* Upgraded to Groovy 2.2.0
* Upgraded to Http Client 4.2.6
* Upgraded to Hamcrest 1.3 (issue 186)

Change log 1.8.1 (2013-06-07)
-----------------------------
* It's now possible to configure the HTTP Multipart mode when sending multi-parts. Configure this in the REST Assured HttpClientConfig (issue 223).
* Non-backward compatible change: Default multi-part mode for multi-part uploads is changed from Browser Compatibility mode to Strict mode.
* Fixed so that getting a single detailed cookie from the Response really works.
* You can now specify a charset more easily when using com.jayway.restassured.http.Charset. For example Charset.JSON.withCharset("UTF-8") (issue 228).
* It's now possible to specify a truststore when doing certificate authentication (thanks to Ian Forsey for the help) (issue 205). Usage:
  given().auth().certificate("file:///my/project/src/test/resources/soapui.p12",  "password", "pkcs12", 8443, truststoreProvider)
* Pretty printing in JsonPath now works for json elements represented as a Java Map (issue 218).
* Reserved Groovy keyword "properties" is automatically escaped in JsonPath (issue 231).
* Response body logger now uses ": " instead of "=" when logging headers to mimic HTTP specification (issue 227).
* Added com.jayway.restassured.builder.MultiPartSpecBuilder that can be used to build more advanced multi-part requests in a fluent way. This also allows you to specify charset for strings in multi-part uploads which was previously not possible (issue 239).
* Added support for setting features in XmlPath using the XmlPathConfig. This can be used to for example disabling external DTD loading. There's also a shortcut for this by using the XmlPathConfig#disableLoadingOfExternalDtd() method (issue 237).

Change log 1.8.0 (2013-04-01)
-----------------------------
* Added support for settings a custom Jackson 2 object factory to JsonPath
* Expecting content type to be a pre-defined content type (such as ContentType.XML) now accepts many kinds of different variations (thanks to exsuscito for the help) (issue 213).
* Upgraded to Groovy 2.1.2
* It's now possible to configure JsonPath with various settings so as returning a BigDecimal instead of floats and doubles. You can do this either statically using:
	  JsonPath.config = new JsonPathConfig(..);
  or per instance:
	  new JsonPath().using(new JsonPathConfig(..)).get(..);
* It's now possible to configure REST Assured to return BigDecimal instead of floats and doubles. You can do this either statically using:
	  RestAssured.config = new RestAssuredConfig().jsonPathConfig(new JsonPathConfig(..));
* Added support for automatically converting a String to BigDecimal in JsonPath
* Non-backward compatible change: com.jayway.restassured.exception.ParsePathException was renamed to com.jayway.restassured.exception.PathException.
* Non-backward compatible change: JsonPath now throws JsonPathException instead of Groovy's JsonException when parsing invalid JSON documents
* Non-backward compatible change: XmlPath now throws XmlPathException instead of PathException when parsing invalid XML documents
* Non-backward compatible change: ObjectMapperDeserializationContext#getResponse() has been renamed to "getDataToDeserialize()". It no longer returns an instance of ResponseBodyData, it now returns an instance of "DataToDeserialize".
* Improved error messages in XmlPath
* Added getPath method to Node and NodeChildren elements in XmlPath which allows you get a subpath using the GPath notation.
* Improved speed of JsonPath when parsing multiple values
* JsonPath and XmlPath has been extracted to their own projects. This means that you can use them with the need to depend on REST Assured.
* Major improvements to XmlPath
* Possible to configure JsonPath and XmlPath both per instance and statically.

Change log 1.7.2 (2012-12-15)
-----------------------------
* StreamVerifier prints better error message when the response content-type is not recognized.
* REST Assured now prints all validation errors in a single test run (issue 207).
* Throws IllegalStateException when incorrectly trying to configure logging on a ResponseSpecBuilder instance after it has been built.

Change log 1.7.1 (2012-11-11)
-----------------------------
* Added methods object variants of setBody and setContent to RequestSpecBuilder.
* Fixed so that form authentication can be added from RequestSpecBuilder.
* You can now add non-string values in form parameters (such as primitives and enums) (issue 201).
* Fixed a bug that accidentally used the content-type as character encoding on object serialization (issue 204).

Change log 1.7 (2012-10-11)
---------------------------
* Fixed an issue with XmlPath when parsing xml attributes and using findAll.
* REST Assured now (finally) builds from Maven 3
* Explicitly registered custom parsers have precedence over default parsers (issue 183).
* It's now possible to manually set the content-type header, e.g. header("content-type", "something") now works (issue 155).
* It's now possible to create custom object mappers and configure existing ones (issue 122).
* It's now possible to define a default object mapper using the com.jayway.restassured.config.ObjectMapperConfig (issue 123).
* ObjectMapper.JACKSON, ObjectMapper.GSON and ObjectMapper.JAXB have been deprecated. Use the corresponding types in enum com.jayway.restassured.internal.mapper.ObjectMapperType instead.
* Added object mapping support for Jackson 2.0 (issue 189).
* Fixed an issue with the com.jayway.restassured.builder.ResponseBuilder that failed to clone the ResponseParserRegistrar.
* JSON path with digits separated by dots can now be processed by JsonPath (issue 195).
* Default filters accumulate and are not merged when reusing request specs (issue 197).
* Fixed so that it's possible to download large (chunked) files again. This was broken in the last release, 1.6.2. (issue 194).
* Added a ConnectionConfig (com.jayway.restassured.config.ConnectionConfig) object that allows you to modify if REST Assured should drop idle connections after each response. Enable connection dropping if you need to make several small and fast requests (e.g. stress testing).
* Path parameters are no longer url encoded if REST Assured url encoding is disabled (issue 181).
* Base path is now shown correctly in request logging when path is a fully qualified URL (issue 145).
* Updated HTTP Client version to 4.2.1.
* Added support for PATCH and OPTIONS requests (issue 164).

Change log 1.6.2 (2012-05-28)
-----------------------------
* You can now use all kinds of Collection instances (and not only List's as in the previous versions) as multi-value parameters (issue 165).
* The specified content-type header is no longer ignored when specifying binary request body content (issue 167).
* REST Assured now closes the HTTP Client connection after each invocation (issue 168).
* JsonPath can now parse JSON documents with attribute names including dots and minus at the same time, e.g.
  	{ "a-b"  : "minus" , "a.b" : "dot"  , "a.b-c" : "both"  }"
  we can now get the result from "a.b-c" using:
        from(json).get("'a.b-c'"); // Returns "both"
  (issue 172).
* Fixed a NPE when getting the session id when no cookies were defined (issue 173).
* You can now serialize Java objects to JSON and XML in multi-part bodies. E.g.
       given().multiPart("controlName", myJavaObject, "application/json"). ..
  will serialize "myJavaObject" to a JSON string automatically (issue 166).
* Fixed a bug that prevented using a single named path parameter multiple times. I.e. this will now work:
	given().
                pathParam("firstName", "John").
        expect().
                body("fullName", equalTo("John John")).
        when().
                get("/{firstName}/{firstName}");
  (issue 169).
* Fixed an issue with RestAssured.urlEncodingEnabled which didn't take request parameters into account when url encoding was disabled (issue 175).

Change log 1.6.1 (2012-04-05)
-----------------------------
* Default encoder is set to binary instead of url encoded. This means that when setting a binary body with an (by REST Assured) unrecognized content-type it will automatically be treated as an octet stream.
* Closed input stream when getting response body as byte-array (issue 163)
* Improved session support. You can now define a session id value in the DSL:
    given().sessionId("1234"). ..
  or for each request:
    RestAssured.sessionId = "1234";
  By default the session id name is JSESSIONID but you can change it using the SessionConfig:
    RestAssured.config = newConfig().sessionConfig(new SessionConfig().sessionIdName("phpsessionid"));
  RequestSpecBuilder has been improved to support session id's as well (issue 28).
* Added methods to the RequestSpecBuilder to enable adding cookies of type com.jayway.restassured.response.Cookie and com.jayway.restassured.response.Cookies.
* JRE proxy settings are now applied by default (thanks to Wolfram Kroll for the patch).

Change log 1.6 (2012-02-18)
---------------------------
* Forked HTTPBuilder. This means that a lot of workarounds that had to be made in the past can be removed in the future. It also means that the Groovy version is updated to version 1.8 and HTML parsing is greatly improved as well as many other minor changes and improvements (issue 112).
* The HTTP Delete method now supports a method body
* PUT request now work for multi part form data uploading
* Added support for pretty-printing the request and response body when logging if content-type is XML, JSON or HTML. Pretty-printing is enabled by default but it could be disabled either by:
	RestAssured.config = config().logConfig(logConfig().enablePrettyPrinting(false));
  or using the DSL:
	expect().log.all(false). ..
  You can also pretty-print the response from the Response object:
	get("/some-xml").prettyPrint();
  (issue 140)
* Fixed a serious issue with content-type validation, it was actually ignored in the previous versions (issue 146).
* XmlPath supports prettifying and pretty-printing XML and HTML, for example:
	String prettyXml = with(someXml).prettify(); // Return a prettified XML string.
  or print the XML to System.out and then return it:
        String prettyXml = with(someXml).prettyPrint(); // Prints and returns a prettified XML string.
  "with" is statically imported from com.jayway.restassured.path.xml.XmlPath (issue 147).
* JsonPath supports prettifying and pretty-printing JSON documents, for example:
	String prettyJson = with(someJson).prettify(); // Return a prettified JSON string.
  or print the JSON to System.out and then return it:
        String prettyJson = with(someJson).prettyPrint(); // Prints and returns a prettified JSON string.
  "with" is statically imported from com.jayway.restassured.path.json.JsonPath (issue 147).
* REST Assured now automatically detects content-types ending with +xml, +json and +html (for example application/something+json) and parses the content with the corresponding parser. This means that you don't need to register custom parsers for these kind of content-types (issue 142).
* Added support for using "bracket notation" for parsing unnamed JSON root arrays. For example consider the following JSON document:
	[{"email":"name1@mail.com","alias":"name one","phone":"3456789"},
         {"email":"name2@mail.com","alias":"name two","phone":"1234567"},
	 {"email":"name3@mail.com","alias":"name three","phone":"2345678"}]
  and let's say you want to get the first e-mail. You can now do like this:
	String email = from(jsonDocument).getString("[0].email");
  (issue 148).
* Response cookies are no longer automatically set in subsequent requests by default. To re-enable this set the "http.protocol.cookie-policy" parameter in the HttpClientConfig to CookiePolicy.RFC_2109 (issue 149).
* Implemented support for no-value parameters, for example:
	given().queryParam("someParameterName").when().get("/something");
  This works for both "request parameters", query parameters and form parameters. (issue 143)
* Added support for getting integer JSON types without escaping, e.g. {"0":"value"} can now be parsed as ..body("0", equalTo("value"). (issue 150)
* REST Assured now takes the charset into consideration for both the request and the response. E.g.
	given().contentType("application/xml; charset=US-ASCII").and().body("my body"). .. will encode the body as US-ASCII.
  you can also specify the default charset for each request:
	RestAssured.config = newConfig().encoderConfig(encoderConfig().defaultContentCharset("US-ASCII"));
  (issue 132)
* Default content encoding charset has been changed from UTF-8 to ISO-8859-1 to comply with the RFC 2616. To change this use the EncoderConfig, e.g.
	RestAssured.config = newConfig().encoderConfig(encoderConfig().defaultContentCharset("UTF-8"));
  You can also specify the default query parameter charset.
* Default decoding content charset has been changed from platform default to ISO-8859-1 to comply with the RFC 2616. To change this use the DecoderConfig, e.g.
	RestAssured.config = newConfig().decoderConfig(decoderConfig().defaultContentCharset("UTF-8"));
* Fixed a bug when setting content type to JSON and using a byte array as body (issue 156).
* Multi-headers and multi-cookie cookie parsing now uses ignore-case equals to identify the entity.
* Upgraded to Hamcrest 1.2.1 and changed the ResponseSpecification to allow for more flexible argument matchers.
* Fixed a bug with the cookie parsing which couldn't deal with cookie values including an equal character (issue 159).
* Added support for argument lists in root and rootPath methods in the response specification (issue 117).
* Request logging filter now logs base path and base uri (issue 145).
* Added method getCompleteRequestPath to com.jayway.restassured.filter.FilterContext. This method provides the fully-qualified URL including scheme and port number to the request path.
* Fixed content encoding for content types ending with +xml, +json and +html to automatically be encoded using the correct encoder methods (issue 160).

Change log 1.5 (2011-12-20)
---------------------------
* Added methods "noFilters" and "noFiltersOfType" to RequestSpecification to allow for removal of filters. This is useful when specifying a default filter statically (e.g. a custom authentication filter) but you need to remove it in a Filter implementation in order to make requests without this filter.
* Improved JsonPath to automatically convert e.g. ints to Strings if explicitly requested.
* Fixed an issue with detailed cookie parsing that prevent the "secured" attribute to be parsed correctly.
* Fixed a bug that failed to apply the root path for multi-body expectations, e.g this will now work:
   expect().
          root("store.book").
          body(
             "category.size()", equalTo(4),
             "author.size()", equalTo(4)
          ).
   when().
          get("/jsonStore");
  (issue 135)
* Fixed a bug with automatic port detection for certain base URI's.
* Improved merging of baseUri, basePath and path. E.g. if the baseUri ends with slash and the path starts with slash one of the slashes are automatically removed (issue 134).
* java.util.Locale will never be serialized to JSON/XML when provided in as a parameter object
* Fixed an issue with PUT method duplicating form parameters as query parameters (issue 137)
* Fixed so that JSON path fragments starting with @ are escaped automatically (issue 138).
* Fixed a serious bug in the response parsing which ignored changes made to the response from a filter when using the DSL (issue 139).
* Created a ResponseBuilder to make it easier to create new Response implementations. This is useful if you're working with filters and want to change the response you get from the sever somehow. E.g.
	Response myResponse = new ResponseBuilder().clone(originalResponse).setBody("Something").build();
* Allows configuring redirect settings using the DSL, e.g.
	given().redirects().max(12).and().redirects().follow(true).when(). .. (issue 24)
* Support for passing in a keystore located on the file-system, e.g.
	given().keystore(new File(".."), "password"). ..
  or for all requests:
	RestAssured.keystore(new File(".."), "password"). ..
  You can also specify the path to the file system as a string as well:
       	given().keystore("some/path/my_keystore.jks", "password"). ..
  In this case REST Assured will first try to find the keystore in the classpath but if it was not found it will look in the file-system (issue 136).
* Status code and status line are now validated before headers and cookies (issue 131).
* Quotes from strings in error messages has been removed.
* Added possibility for more advanced configuration by providing a RestAssuredConfig instance. Right now you can configure the parameters of HTTP Client, Redirect and Log settings. Examples:
  For a specific request:
	given().config(newConfig().redirect(redirectConfig().followRedirects(false))). ..
  or using a RequestSpecBuilder:
	RequestSpecification spec = new RequestSpecBuilder().setConfig(newConfig().redirect(redirectConfig().followRedirects(false))).build();
  or for all requests:
	RestAssured.config = config().redirect(redirectConfig().followRedirects(true).and().maxRedirects(0));
  "config()" and "newConfig()" can be statically imported from com.jayway.restassured.config.RestAssuredConfig
* Non-backward compatible change: getRequestParams and getQueryParams() now returns Map<String, ?> instead of Map<String, String> in FilterableRequestSpecification.
* Added getFormParams() and getPathParams() to com.jayway.restassured.specification.FilterableRequestSpecification.
* Header- and Cookie names are now case-insentive in com.jayway.restassured.response.Headers and com.jayway.restassured.response.Cookies.
* Added a new method called filters(Filter filter, Filter...additionalFilter) in the com.jayway.restassured.specification.RequestSpecification and com.jayway.restassured.RestAssured.
* Logging has undergone a major uplift. You can now not only log the response body but also headers, cookies and status line. You can also log the request details as defined in the request specification. Thus the following:
	given().log(). .. // Log the response body in versions prior to 1.5
  and
	expect().log(). .. // Also logs the response body in versions prior to 1.5
  will now look like this:
	given().log().body(). .. // Log the _request_ body in versions >= 1.5
  and
	expect().log().body() .. // Log the response body in versions >= 1.5
  You can also log e.g. only headers in the request and the response:
	given().log().headers(). .. // Log only the request headers
  and
	expect().log().headers(). .. // Log only the response headers
  Previously there was a method called "logOnError" in both the request and response specification. This has now been replaced with the following method in the response specification:
	expect().log().ifError(). ..
  This change is not backward compatible (issue 81).

Change log 1.4.5 (2011-11-08)
-----------------------------
* REST Assured can now parse responses with no-value (empty) cookies (issue 124).
* Added support for serializing objects to a parameter if the content-type is set:
  given().
          contentType("application/json").
          queryParam("category", "Games").
          formParam("object", new GameObject(..)). // GameObject will be serialized to JSON
  when().
          post("/somewhere");
  (issue 127).
* Fixed a bug with multi-value form parameters when using PUT.
* You can now create multi-value headers using e.g.: given().header("headerName", "value1", "value2")... This will create TWO headers, "headerName=value1" and "headerName=value2".
* You can now create multi-value cookies using e.g.: given().cookie("cookieName", "value1", "value2")... This will create TWO cookies, "cookieName=value1" and "cookieName=value2".
* Fixed a bug in the specification merger which caused FormAuthFilters to be applied twice if using multiple specifications with form auth.
* Fixed a serious bug in the cookie response parsing that caused cookie attributes to be parsed as a new cookie (issue 130).
* This version introduces a number of non-backward compatible change: The headers() and getHeaders() methods in com.jayway.restassured.response.Response no longer return a Map of key-value pairs, it now returns an instance of com.jayway.restassured.response.Headers. The reason for this is to allow for multi-value headers. These are headers that has several values for the same header name, e.g. "headerName=value1" and "headerName=value2". See javadoc in com.jayway.restassured.response.Headers for more info.
* Added support for getting "detailed cookies". A detailed cookie contains information such as Expiry Date, Path, Version etc. To get a detailed cookie use com.jayway.restassured.response.Response#getDetailedCookie(<cookie name>) or to get all use com.jayway.restassured.response.Response#getDetailedCookies().
* Added support for sending detailed cookies, e.g.
	Cookie someCookie = new Cookie.Builder("some_cookie", "some_value").setSecured(true).build();
	given().cookie(someCookie).and().expect().body(equalTo("x")).when().get("/cookie");
  you can also send multiple detailed cookies at the same time:
  	Cookie cookie1 =  Cookie.Builder("username", "John").setComment("comment 1").build();
	Cookie cookie2 =  Cookie.Builder("token", 1234).setComment("comment 2").build();
	Cookies cookies = new Cookies(cookie1, cookie2);
	given().cookies(cookies).then().expect().body(equalTo("username, token")).when().get("/cookie");
  (issue 99).
* Added support for mapping a path to a Java object in JsonPath, e.g: Book book = from(JSON).getObject("store.book[2]", Book.class); (half of issue 125)

Change log 1.4 (2011-10-07)
---------------------------
* Better error message when an actual JSON or XML path value doesn't match the expected value (issue 104).
* Removed dependency to spring-web in example project
* Improved support for getting a list with an explicit type using XmlPath (issue 106).
* RestAssured.baseURI now works as expected. You can now use e.g. RestAssured.baseURI = "http://somehost.org:1234" and the subsequent requests will automatically go to that URI as base (issue 54).
* Rest Assured now throws a java.lang.AssertionError instead of AssertionFailedException (issue 100).
* Added support for setting a default Parser. This parser will automatically be used to parse all responses whose content-type doesn't match a pre-defined parser. You can set the default parser for all responses using:
	  RestAssured.defaultParser = Parser.JSON;
  or for a single response:
	  expect().defaultParser(Parser.JSON).when(..).
  or using a response specification builder:
	  new ResponseSpecBuilder().setDefaultParser(Parser.JSON).build();
 (issue 107).
* Improved parsing of response content. If no body expectations are defined then the content is no longer encoded to an intermediate data structure when calling methods such as "asString", "asByteArray" etc on the Response object. This increases the performance of Rest Assured when using no body expectations (e.g. get("/something").asString()) (issue 109).
* Added an "asInputStream" to the Response object. This means that you can now do e.g. "get("/something").asInputStream()" to get the body returned as an input stream.
* Support for mapping a response content body directly to an Object using either Jackson or Gson for JSON responses and JAXB for XML responses. Usage example:
	SomeObject someObject = get("/something").as(SomeObject.class);
  This requires the the response content-type is defined. If you want to map the response using a specific object mapper you can do like this:
		SomeObject someObject = get("/something").as(SomeObject.class, ObjectMapper.GSON);
  Note that Rest Assured doesn't explicitly depend on any of the object mappers so you need to add them to the classpath manually or using a Maven dependency (issue 19).
* Support for mapping a Java Object to JSON or XML using Jackson, Gson or JAXB. Use e.g. "given().contentType("application/json").and().body(someObject).when().post("/something");"
  You can also specify an explicit object mapper instead of a content-type:
	given().body(someObject, ObjectMapper.JACKSON).when().post("/something");
  (issue 118).
* getMap with explicit type now converts the key and value to the defined type for both JsonPath and XmlPath
* JsonPath.getList with an explicit type now converts all list members to the defined type (issue 114).
* Fixed a bug when defining root path that ends with a dot and a path that starts with a dot.
* You can now provide ints, floats etc to the request body. E.g. given().body(42).when().post("/somewhere");
* getString in JsonPath converts the result to string if needed (issue 115).
* Added "path", "jsonPath" and "xmlPath" methods to ResponseBody object. This make it very convenient to make a request and parse a single path from the response. E.g.
    String messageBody = get("/message").path("message.body");
  In this example the response content-type determines whether JsonPath or XmlPath should be used. It could also be defined explicitly:
    String messageBody = get("/message").jsonPath().getString("message.body");
  (issue 110, 116).
* Fixed a bug when using a form auth per request and a default form auth which added two form auth filters to the filter list causing multiple requests to made to the server.

Change log 1.3.1 (2011-09-20)
-----------------------------
* Fixed a trivial bug in the error message that is displayed when no parser is found for a certain content type (issue 103).
* Fixed a bug that caused the response body to be parsed as JSON if Content-Type of the response was JSON even though no body matchers were specified (issue 102).
* Improved List parsing with XmlPath. E.g. from(XML).getList("shopping.category.item.price") will now automatically convert the output from NodeChildren to a List. Also from(XML).getList("shopping.category.item.price", Float.class) will automatically convert all list members to floats.
* When result from XmlPath expression is a single entity it's treated as a list if explicitly defined: E.g. from(XML).getList("shopping.category.item.price[0]") and from(XML).get("shopping.category.item.price.list()") will return a list (issue 59).
* All parameter values now take Object as parameter type. This means that you can supply e.g. ints, floats etc and not only Strings as parameter values. E.g. before you had to do given().param("number", String.valueOf(1)).when().get(..) but now you can simply do given().param("number", 1).when().get(..); (issue 82).
* You can now register custom parsers directly in the response specification and the response specification builder and not only statically in the RestAssured class. E.g. expect().parser("some/xml", Parser.XML).when().get("/something"); (issue 101).

Change log 1.3 (2011-09-05)
---------------------------
* Added support for uploading files, input streams, byte arrays and text using multi-part form data upload. You can use the "multiPart" method to specify what to upload. E.g.
  given().multiPart(new File("/home/user/myFile.txt").when().post("/upload"); (issue 93)
* Request specification details such as port number are now taking into account when using form authentication (issue 95).
* You can now pass string data to the content method in the RequestSpecification, e.g. given().content("{ \"message\" : \"hello world
\"}").then().expect().statusCode(200).when().post("/json");
* Added methods to get NodeChildren and Node to XmlPath class (issue 54 and 58).
* Improved automatic escaping of attributes in cases of ranges. E.g. you can now type "records.car[0..1].@year" when parsing XML instead of having to escape the year attribute like "records.car[0..1].'@year'".
* Improved escaping of the minus character inside closures when parsing JSON, XML and HTML.
* When using XmlPath and getting primitive values from an XML graph the result is automatically converted to the expected primitive type if needed and possible.
* Added support for depth-first parsing of XML using the double-star notation, e.g. "int chocolatePrice = from(XML).getInt("shopping.**.find { it.name == 'Chocolate' }.price");" (issue 94).
* RestAssured now uses the threads classloader to load net.sf.json.AbstractJSON instead of root classloader to avoid problems with Groovy Grape (issue 92).
* When specifying a request body and using a custom/unregistered content-type the body will automatically be URL Encoded. Previously a NPE was thrown because no content encoder was registered to HTTP Builders encoder registry for the specified content type. (issue 96).
* Fixed a bug in RequestSpecificationBuilder that treated form parameters as query parameters.

Change log 1.2.3 (2011-08-18)
-----------------------------
* Fixed a bug when using PUT with multi-value form parameters.
* Improved path parameter support. Rest Assured no longer URL encodes path parameters in order to detect them as query parameters.
* JsonPath now converts from Groovy primitives to Java primitives correctly (thanks to Erik Hjortsberg)
* Added support for enabling and disabling URL encoding for parameters. This is useful if the parameters are URL encoded before you supply them to Rest Assured. In cases like this you need to use given().urlEncodingEnabled(false), RestAssured.urlEncodingEnabled = false or specify it using the RequestSpecificationBuilder to avoid double URL encoding (issue 88).
* Fixed URL to web page in pom.xml (issue 90)
* Added a no-argument get method to JsonPath and XmlPath to easier parse the entire object graph (issue 91).
* Better support for re-usable path expressions by using arguments. E.g. let's say you want to expect a complex path like this:
	  expect().
		   body("filters.filterConfig[0].filterConfigGroups.find { it.name == 'GroupName' }.includes", hasItem("first")).
		   body("filters.filterConfig[1].filterConfigGroups.find { it.name == 'GroupName' }.includes", hasItem("second")).
          ..
  The only difference between the two body paths is the index of the "filterConfig". A root path wouldn't help since previously you could only append a path to the root path and not supply arguments to it. Now you can do:
  	  expect().
		   root("filters.filterConfig[%d].filterConfigGroups.find { it.name == 'GroupName' }.includes").
		   body("", withArgs(0), hasItem("first")).
		   body("", withArgs(1), hasItem("second")).

  I.e. the indices 0 and 1 was replaced with a "%d" and you then supply the arguments to the path expression using the "withArgs" method located in com.jayway.restassured.RestAssured. You can also use the "withArgs" method without
  using a root-path (issue 17, 80).

Change log 1.2.2 (2011-06-28)
-----------------------------
* Added support for parsing an entire JSON graph. E.g. let's say you have a JSON snippet like this:
  [{"email":"name1@mail.com","alias":"name one","phone":"3456789"},
   {"email":"name2@mail.com","alias":"name two","phone":"1234567"},
   {"email":"name3@mail.com","alias":"name three","phone":"2345678"}]
  You can then parse the entire JSON snippet to a List of Map like this:
     List<Map<String, String>> result = from(json).get("$");
  or
   List<Map<String, String>> result = from(json).get("");
  (issue 78)
* Added support for explicitly specifiying form parameters, e.g. using given().formParam("name", "value"). This is useful e.g. when sending a PUT request with both form params and query params (issue 75).
* It's now possible to check that a header does NOT exist: expect().header("someheader", nullValue()). (issue 74).
* Support for path parameters. E.g. get("/{firstName}/{lastName}", "John", "Doe") will send a GET request to "http://localhost:8080/John/Doe". You can also specify path params like this:
  given().
          pathParam("firstName", "John").
          pathParam("lastName", "Doe").
  when().
          get("/{firstName}/{lastName}");
 (issue 36)
* Support for specifying a Java keystore when using SSL. This is useful when you run into e.g. SSLPeerUnverifiedException when the server has an invalid certificate. Usage:
  given().keystore("/pathToJksInClassPath", <password>)
  For more info refer to https://github.com/jgritman/httpbuilder/wiki/SSL (issue 79).
* Fixed an issue that could cause parameters to be treated as lists parameters.

Change log 1.2.1 (2011-05-23)
-----------------------------
* Fixed an issue when defining default request specifications with form parameters when using POST.
* Added support for getting the content type in the com.jayway.restassured.response.Response object.
* Fixed a major issue with filters that caused the response expecations to be verified before filter chain was completed.
* Added "from" method to XmlPath and JsonPath (issue 60).
* XmlPath now supports parsing HTML by setting CompatibilityMode to HTML, e.g. new XmlPath(CompatibilityMode.HTML, <some html>);.
* Form authentication now uses HTML parsing when parsing the login page (before XML parsing was used which was very fragile).
* Improved HTML parsing with Groovy closures

Change log 1.2 (2011-05-22)
---------------------------
* Better support for multi-value parameters. You can now defined them using a List:
    with().param("list", asList("1", "2", "3)). ..
  or with var-args:
    with().param("list", "1", "2", "3). ..
* Added support for form authentication: given().auth().form("username", "password")... Rest Assured will automatically parse the login page and try to find the form action and the username and password input fields. If it fails to do so or if you want a faster request you can supply a FormAuthConfig as a third param that providers Rest Assured with these parameters. E.g. given().auth().form("username", "password", new FormAuthConfig(..)).. There's a pre-defined form auth config for Spring Security: given().auth().form("username", "password", FormAuthConfig.springSecurity())... You can also specify form as default authentication for all requests: RestAssured.authentication = form("username", "password");. (issue 61).
* Added support for filters with which you can inspect and alter a request before it's actually committed and also inspect and alter the response before it's returned to the expectations. You can regard it as an "around advice" in AOP terms. Filters can be used to implement custom authentication schemes, logging, session management etc. You implement com.jayway.restassured.filter.Filter and register it using: given().filter(new MyFilter()). .. or set it as default: RestAssured.filters(asList(new MyFilter()); (issue 71).
* You can now define and expect cookies without values using e.g. given().cookie("some_cookie").. or expect().cookie("some_cookie").. (issue 69).
* You can now specify default request and response content type using RestAssured.requestContentType(..) and RestAssured.responseContentType(..). (issue 68).
* Support for specifying string content types (issue 72).
* Support for specifying default request and response specifications (issue 67).
* Added support for printing response body using filters. E.g. given().filter(ErrorLogger.errorLogger()).. will print the response body if an error occurred (400 <= status code <= 500). You can also use the ResponseLoggingFilter to print response bodies for all status codes: given().filter(ResponseLoggingFilter.loggingFilter()).., or you can make it print only for specific status codes: given().filter(ResponseLoggingFilter.logResponseIfStatusCodeIs(302)).. and you can even use Hamcrest matchers: given().filter(ResponseLoggingFilter.logResponseIfStatusCodeIs(greaterThan(200)))..
  There's also a shortcut for error logging:
    given().logOnError(). or expect().logOnError(). ..
  and for logging:
    given().log(). or expect().log(). (issue 66).
* Added support for easily printing the response after a request (if the expectations pass), e.g. expect().body("greeting", equalTo("Greetings John Doe")).when().get("/greet?firstName=John&lastName=Doe").print();

Change log 1.1.7 (2011-04-26)
-----------------------------
* Added support for mixing form and query parameters when using the POST method. E.g. "with().param("firstName", "John").and().queryParam("lastName", "Doe").expect().body("greeting.lastName", equalTo("Doe")).post("/greetXML");"
  When using POST the "param" method adds form parameters to the request and "queryParam" adds query parameters of the request.
* Added support for multi-value paramters, e.g. with().param("list", "first").and().param("list", "second").when().get("/something") will now send a GET request to "/something" with parameter list including first and second. (issue 62).

Change log 1.1.6 (2011-03-29)
-----------------------------
* Preemptive basic authentication really works (issue 52).

Change log 1.1.5 (2011-03-28)
-----------------------------
* Added suport for preemptive basic authentication. E.g. given().auth().preemptive().basic("username", "password").when().get("/secured");. You can also set preemptive basic authentication as default authentication scheme using:
  RestAssured.authentication = preemptive().basic("username", "password"); (issue 45)
* Added support for specifying a root path. E.g. instead of writing:
  expect().
           body("x.y.firstName", is(..)).
           body("x.y.lastName", is(..)).
           body("x.y.age", is(..)).
           body("x.y.gender", is(..)).
  when().
           get("/something");
  you can use a root path and do:
  expect().
           rootPath("x.y").
           body("firstName", is(..)).
           body("lastName", is(..)).
           body("age", is(..)).
           body("gender", is(..)).
  when().
          get("/something");
  You can also set a default root path using: RestAssured.rootPath = "x.y"; (issue 47)
* It's now possible to reuse specifications accross different tests (issue 46). E.g.
  ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(200).expectBody("x.y.size()", is(2)).build();

  expect().
         spec(responseSpec).
         body("x.y.z", equalTo("something")).
  when().
         get("/something");

  The "responseSpec" can now be reused in a completely different test without having to duplicate the expecations in the "responseSpec" for each test.

  The same thing can be achieved for request specifications:
  RequestSpecification requestSpec = new RequestSpecBuilder().addParameter("parameter1", "value1").build();

  given().
          spec(requestSpec).
  expect().
          body("x.y.z", equalTo("something")).
  when().
          get("/something");
* You can now get the response body content when request body is empty (issue 49).
* Added support for getting response body even when using body expecations. I.e. now this works:
  String body = expect().body("x.y.z", equalTo("something")).when().get("/x").andReturn().body().asString(); (issue 50)
* Specifying a fully-qualied request url overrides default base path, base uri, and port (issue 41).

Change log 1.1.2 (2011-03-04)
-----------------------------
* Fixed so that POST requests can return a response (e.g. Response response = post("/somewhere");) when an error occurred (status code 400 to 999). (issue 37).
* You can now get the status line and status code from the Response (issue 40). E.g
      Response" response = get("/something");
      String statusLine = response.getStatusLine();"
* Corrected some javadoc issues.

Change log 1.1.1 (2011-03-02)
-----------------------------
* Added support for getting headers and cookies from the Response, e.g. String headerValue = get("/something").andReturn().header("headerName"); (issue 27)
* Fixed so that you don't need to add a "@" when calling getAttribute(..) on Node in XmlPath (issue 34)
* Added support for validating XML body using XSD e.g. "expect().body(matchesXsd(xsd)).when().get("/carRecords");" where matchesXsd(..) is a REST-Assured Hamcrest matcher located in com.jayway.restassured.matcher.RestAssuredMatchers and "xsd" can be either a String, InputStream, Reader, URL or File (issue 29).
* Added support for validating XML body using DTD e.g. "expect().body(matchesDtd(dtd)).when().get("/videos");" where matchesDtd(..) is a REST-Assured Hamcrest matcher located in com.jayway.restassured.matcher.RestAssuredMatchers and "dtd" can be either a String, InputStream, URL or File (issue 29).
* Improved error messages on illegal paths when expecting XML (issue 35).


Change log 1.1 ((2011-02-18)
----------------------------
* Added support for specifying base path using "RestAssured.basePath = /resource". E.g. let's say that the base URI is http://localhost and base path is "/resource" will make create a request to "http://localhost/resource/something" when doing a 'get("/something")'. Default value is empty. (issue 13)
* Support for specifying request/query parameters in the url, e.g. get("/something?param1=first&param2=second"). (issue 23)
* Fixed a bug in RestAssuredResponse parser that caused a NPE when the input stream was null. (issue 25)
* Major improvements to XML expectations. It now uses Groovy syntax for the expectation string to allow for much better expectations! Note that this fix will break backward compatibility on some expectations. E.g. given
        <greeting>
	    <name>
                <firstName>John</firstName>
                <lastName>Doe</lastName>
            </name>
        </greeting>
  you used to do:
        expect().body("greeting.name", hasItems("John", "Doe"))..
  Now this will not work, instead you have to do:
        expect().body("greeting.name.children()", hasItems("John", "Doe"))..
  But this also means that you can do:
        expect().body("greeting.name.size()", equalsTo(2))..
  See http://www.groovy-lang.org/processing-xml.html#_manipulating_xml for more info about the syntax.
* Support for expecting on XML attributes, e.g. expect().body("greeting.name.@firstName", equalTo("John")).when().get("/greetXMLAttribute?firstName=John&lastName=Doe");
* When forcing plain text verification for e.g. JSON or XML responses the response content type is no longer changed. Before this could cause Jersey to refuse to refuse the return a response. (issue 10)
* PUT requests now supports specifying binary a request body
* Major improvements to JSON expectations. It now uses Groovy syntax for the expectation string to allow for much better expectations! Note that this fix will break backward compatibility on some expectations.
  - JSON lists are always returned as Java lists which means that you should use the hasItem(..) hamcrest matcher and not hasItemsInArray(..) hamcrest matcher.
* Added support for specifying default authentication scheme. E.g. use RestAssured.authentication = basic("username", "password") to cause all subsequent request to use basic authentication. You can reset to no authentication using RestAssured.reset(); (issue 20)
* Added support for registering a predefined parser for unsupported mime-types by using RestAssured.registerParser(<mime-type>, <parser>). E.g. to register that mime-type 'application/vnd.uoml+xml' should be parsed using the XML parser do: RestAssured.registerParser("application/vnd.uoml+xml", Parser.XML);. You can also unregister a parser using RestAssured.unregisterParser("application/vnd.uoml+xml");. (issue 8)
* Added XmlPath object which allows you to parse an XML response from a request easily. E.g.
  String xml = post("/greeting").asString();
  String firstName = with(xml).get("greeting.firstName");
  For more information refer to the javadoc of com.jayway.restassured.path.xml.XmlPath
* Added JsonPath object which allows you to parse an JSON response from a request easily. E.g.
  String json = post("/greeting").asString();
  String firstName = with(json).get("greeting.firstName");
  For more information refer to the javadoc of com.jayway.restassured.path.json.JsonPath

Change log 1.0.3 (2011-01-17)
-----------------------------
* Fixed a bug in the JSON parsing which prevent parsing of nested arrays (issue 15)
* Added support for getting an index in a JSON array. E.g. expect().body("items.get(0)", equalTo("firstIndex")).when().get("/something");. Assuming that "items" is an array then "items.get(0)" returns the first element in that array.
* Fixed so that you can expect on null values in JSON arrays.
* Request senders can now return the body as byte array or string. E.g. get("/something").asString() makes GET request to "/something" and returns the response body as a string. This is useful if you want to debug the response while creating your test or if you want to use third-party tools to validate the response. Note that it only works if you don't specify any expectations before making the request.

Change log 1.0.2 (2011-01-12)
-----------------------------
* JSON and XML matching now supports many more content types than before. Before you could only use XML matching for content type application/xml and JSON for application/json.
* Support for HTML verification
* Support for RSS verification (content type application/rss+xml)

Change log 1.0.1 (2010-12-27)
-----------------------------
* Refactored AuthenticationSpecification to be a Java interface in order to avoid Groovy methods being exposed and to allow for Javadoc.
