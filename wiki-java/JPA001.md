#Revisão de JPA

## (I) Entidades

As classes da nossa aplicação que devem ser mapeadas para tabelas do banco de dados são anotadas com @Entity. Cada instância de uma classe anotada com @ENTITY deve possuir um identificador único. Em geral, esse identificador é um atributo numérico que deve ser anotado com @Id.

```java

@Entity
class Pessoa {

@Id
private Long id;
}

```

Por convenção, a classe PESSOA será mapeada para uma tabela com o mesmo nome (Pessoa). O atributo ID será mapeado para uma coluna com o mesmo nome (id) na tabela Pessoa. Podemos não seguir o comportamento padrão e aplicar nomes diferentes para as tabelas e colunas utilizando as anotações @Table e @Column.

A coluna correspondente ao atributo ID será a chave primária da tabela PESSOA por causa da anotação @ID.

```java

@Entity
@Table(name = "tbl_pessoas")
class Pessoa {

@Id
@Column(name = "col_id")
private Long id;
}

```

(II) Definindo Restrições

Podemos definir algumas restrições para os atributos das nossas entidades através das propriedades da anotação @COLUMN. Veja as principais propriedades abaixo:

* length:Limita a quantidade de caracteres de um valor string
* nullable: Determina se o campo pode possuir valores NULL ou não
* unique: Determina se uma coluna pode ter valores repetidos ou não

```java

@Entity
class Pessoa {

@Id
private Long id;

@Column(length=30,nullable=false,unique=true)
private String nome;
}

```

## (III) @GeneratedValue

Em geral, os bancos de dados oferecem algum mecanismo para gerar os valores de uma
chave primária simples e numérica. Do ponto de vista do desenvolvedor JPA, para deixar com o banco de dados a responsabilidade de gerar os valores de uma chave primária simples e numérica, basta aplicar a anotação @GeneratedValue.

```java

@Entity
class Pessoa {

@Id
@GeneratedValue
private Long id;
}

```

## (IV) Mapeamento automático

Alguns tipos do Java são mapeados automaticamente para tipos correspondentes do banco
de dados tirando dos desenvolvedores esse trabalho. Eis uma listagem dos tipos que são mapeados automaticamente:

* Tipos primitivos (byte, short, char, int, long, float, double e boolean)
* Classes Wrappers (Byte, Short, Character, Integer, Long, Float, Double e Boolean)
* String
* BigInteger e BigDecimal
* java.util.Date e java.util.Calendar
* java.sql.Date, java.sql.Time e java.sql.Timestamp
* Array de byte ou char
* Enums
* Serializables

## (V) Large Objects (LOB)

Eventualmente, dados maiores do que o comum devem ser armazenados no banco de dados. Por exemplo, uma imagem, uma música ou um texto com muitas palavras. Para esses casos, os bancos de dados oferecem tipos de dados específicos. Do ponto de vista do desenvolvedor JPA, basta aplicar a anotação @LOB em atributos do tipo STRING, BYTE [], CHAR [] ou CHARACTER [] que o provedor (Hibernate, TopLink ou outra implementação de JPA) utilizará os procedimentos adequados para manipular esses dados.

```java

@Entity
class Pessoa {

@Id
@GeneratedValue
private Long id;
@Lob
private byte[] avatar;
}

```

## (VI) Data e Hora

Comumente, as aplicações Java utilizam as classes JAVA.UTIL.DATE e JAVA.UTIL.CALENDAR
para trabalhar com datas e horas. Essas classes são mapeadas automaticamente para tipos adequados no banco de dados. Portanto, basta declarar os atributos utilizando um desses dois tipos nas classes que serão mapeadas para tabelas.

```java

@Entity
class Pessoa {

@Id
@GeneratedValue
private Long id;
private Calendar nascimento;
}

```

Por padrão, quando aplicamos o tipo JAVA . UTIL .DATE ou JAVA . UTIL .C ALENDAR, tanto
data quanto hora serão armazenados no banco de dados. Para mudar esse comportamento, devemos aplicar a anotação @Temporal escolhendo uma das três opções abaixo:

* TemporalType.DATE : Apenas data (dia, mês e ano).
* TemporalType.TIME : Apenas horário (hora, minuto e segundo)

```java

@Entity
class Pessoa {

@Id
@GeneratedValue
private Long id;

@Temporal(TemporalType.DATE)
private Calendar nascimento;
}

```

## (VII) Dados Transientes

Eventualmente, não desejamos que alguns atributos de um determinado grupo de objetos
sejam persistidos no banco de dados. Nesse caso, devemos aplicar o modificador transient ou a anotação @Transient.

```java

@Entity
class Pessoa {

@Id
@GeneratedValue
private Long id;

@Temporal(TemporalType.DATE)
private Calendar nascimento;

@Transient
private int idade;
}

```
## (VIII) Relacionamentos

Os relacionamentos entre as entidades de um domínio devem ser expressos na modelagem através de vínculos entre classes. Podemos definir quatro tipos de relacionamentos de acordo com a cardinalidade:

* One to One (Um para Um): Por exemplo, um estado é governado por apenas um governador e um governador governa apenas um estado.
* One to Many (Um para Muitos): Por exemplo, um departamento possui muitos funcionários e um funcionário trabalha em apenas em um departamento.
* Many to One (Muitos para Um): Por exemplo, um pedido pertence a apenas um cliente e um cliente faz muitos pedidos.
* Many to Many (Muitos para Muitos): Por exemplo, um livro possui muitos autores e um autor possui muitos livros.

### (VIIIa) One to One

Suponha que no nosso domínio há duas entidades: Estado e Governador. Devemos criar
uma classe para cada entidade e aplicar nelas as anotações básicas de mapeamento.

```java

@Entity
class Estado {

@Id
@GeneratedValue
private Long id;
}

@Entity
class Governador {

@Id
@GeneratedValue
private Long id;
}
```

Como existe um relacionamento entre estados e governadores devemos expressar esse vín-culo através de um atributo que pode ser inserido na classe ESTADO.

```java

@Entity

class Estado {
@Id
@GeneratedValue
private Long id;
private Governador governador;
}
```

Além disso, devemos informar ao provedor do JPA que o relacionamento que existe entre um estado e um governador é do tipo One to One. Fazemos isso, aplicando a anotação
@OneToOne no atributo que expressa o relacionamento.

```java

@Entity
class Estado {

@Id
@GeneratedValue
private Long id;
@OneToOne
private Governador governador;
}
```

No banco de dados, a tabela referente a classe ESTADO possuíra uma coluna de relacionamento também chamada de join column. Em geral, essa coluna será definida como uma chave estrangeira associada à tabela referente à classe GOVERNADOR.
Por padrão, o nome da coluna de relacionamento é a concatenação com “_” da entidade alvo do relacionamento com o nome da chave primária também da entidade alvo. No exemplo de estados e governadores, a join column teria o nome governador_id. Podemos alterar o nome padrão das join columns aplicando a anotação @JoinColumn.

```java
@Entity
class Estado {

@Id
@GeneratedValue
private Long id;
@OneToOne
@JoinColumn(name="gov_id")
private Governador governador;
}
```

## (VIIIb) One to Many

Suponha que no nosso domínio há duas entidades: Departamento e Funcionário. Criaríamos duas classes com as anotações básicas de mapeamento.

```java 

@Entity
class Departamento {

@Id
@GeneratedValue
private Long id;
}

@Entity
class Funcionario {

@Id
@GeneratedValue
private Long id;
}

```

Como existe um relacionamento entre departamentos e funcionários devemos expressar
esse vínculo através de um atributo que pode ser inserido na classe DEPARTAMENTO. Supondo que um departamento pode possuir muitos funcionários, devemos utilizar uma coleção para expressar esse relacionamento.

```java

@Entity
class Departamento {

@Id
@GeneratedValue
private Long id;
private Collection<Funcionario> funcionarios;
}

```

Para informar a cardinalidade do relacionamento entre departamentos e funcionários, devemos utilizar a anotação @OneToMany na coleção.

```java

@Entity
class Departamento {

@Id
@GeneratedValue
private Long id;
@OneToMany
private Collection<Funcionario> funcionarios;
}
```

No banco de dados, além das duas tabelas correspondentes às classes DEPARTAMENTO e
FUNCIONARIO, uma terceira tabela será criada para relacionar os registros dos departamentos com os registros dos funcionários. Essa terceira tabela é chamada de tabela de relacionamento ou join table.

Por padrão, o nome da join table é a concatenação com “_” dos nomes das duas entidades. No exemplo de departamentos e funcionários, o nome do join table seria Departamento_Funcionario. Essa tabela possuíra duas colunas vinculadas às entidades que formamo relacionamento. No exemplo, a join table DEPARTAMENTO_FUNCIONARIO possuíra uma coluna chamada Departamento_id e outra chamada funcionarios_id.

Para personalizar os nomes das colunas da join table e dá própria join table, podemos aplicar a anotação @JoinTable no atributo que define o relacionamento.

```java

@Entity
class Departamento {

@Id
@GeneratedValue
private Long id;
@OneToMany
@JoinTable(name="DEP_FUNC",
joinColumns=@JoinColumn(name="DEP_ID"),
inverseJoinColumns=@JoinColumn(name="FUNC_ID"))
private Collection<Funcionario> funcionarios;
}
```

## (VIIIc) Many to One

Suponha que no nosso domínio há duas entidades: Pedido e Cliente. As duas classes que
modelariam essas entidades seriam anotadas com as anotações principais de mapeamento.

```java

@Entity
class Pedido {

@Id
@GeneratedValue
private Long id;
}

@Entity
class Cliente {

@Id
@GeneratedValue
private Long id;
}

```

Como existe um relacionamento entre pedidos e clientes devemos expressar esse vínculo
através de um atributo que pode ser inserido na classe PEDIDO. Supondo que um pedido
pertence a um único cliente, devemos utilizar um atributo simples para expressar esse relacionamento.

```java

@Entity
class Pedido {

@Id
@GeneratedValue
private Long id;
private Cliente cliente;
}

```

Para informar a cardinalidade do relacionamento entre pedidos e clientes, devemos utilizar a anotação @ManyToOne no atributo.

```java

@Entity
class Pedido {

@Id
@GeneratedValue
private Long id;
@ManyToOne
private Cliente cliente;
}
```

No banco de dados, a tabela referente a classe PEDIDO possuíra uma join column vinculada à tabela da classe CLIENTE. Por padrão, o nome da join column é a concatenação com “_” da entidade alvo do relacionamento com o nome da chave primária também da entidade alvo. No exemplo de pedidos e clientes, o nome da join column seria cliente_id. Podemos alterar o nome padrão das join columns aplicando a anotação @JoinColumn.

```java

@Entity
class Pedido {

@Id
@GeneratedValue
private Long id;
@ManyToOne
@JoinColumn(name="cli_id")
private Cliente cliente;
}

```

## (VIIId) Many to Many

Suponha que no nosso domínio há duas entidades: livros e autores. As classes e com as
anotações básicas de mapeamento seriam mais ou menos assim:

```java

@Entity
class Livro {

@Id
@GeneratedValue
private Long id;
}

@Entity
class Autor {

@Id
@GeneratedValue
private Long id;
}
```

Como existe um relacionamento entre livros e autores devemos expressar esse vínculo através de um atributo que pode ser inserido na classe LIVRO. Supondo que um livro pode ser escrito por muitos autores, devemos utilizar uma coleção para expressar esse relacionamento.

```java

@Entity
class Livro {

@Id
@GeneratedValue
private Long id;
private Collection<Autor> autores;
}
```

Para informar a cardinalidade do relacionamento entre livros e autores, devemos utilizar a anotação @ManyToMany na coleção.

```java

@Entity
class Livro {

@Id
@GeneratedValue
private Long id;
@ManyToMany
private Collection<Autor> autores;
}
```

No banco de dados, além das duas tabelas correspondentes às classes LIVRO e AUTOR,
uma join table é criada para relacionar os registros dos livros com os registros dos autores. Por padrão, o nome da join table é a concatenação com “_” dos nomes das duas entidades. No exemplo de livros e autores, o nome do join table seria Livro_Autor. Essa tabela possuíra duas colunas vinculadas às entidades que formam o relacionamento. No exemplo, a join table LIVRO_AUTOR possuíra uma coluna chamada Livro_id e outra chamada autores_id.

Para personalizar os nomes das colunas da join table e dá própria join table, podemos aplicar a anotação @JoinTable no atributo que define o relacionamento.

```java

@Entity
class Livro {

@Id
@GeneratedValue
private Long id;
@ManyToMany
@JoinTable(name="Liv_Aut",
joinColumns=@JoinColumn(name="Liv_ID"),
inverseJoinColumns=@JoinColumn(name="Aut_ID"))
private Collection<Autor> autores;
}

```
Source: Material da Pós java UTFPR-2015















